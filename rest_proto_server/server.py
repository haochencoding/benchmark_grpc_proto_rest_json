#!/usr/bin/env python3
"""
FastAPI server that speaks protobuf over HTTP.

The request and response bodies are the **raw bytes** of the
timestream.RecordListRequest / RecordListResponse messages defined in
`records.proto`.

A JSON-lines logger (see utils/logger.py) is used exactly like in the
gRPC version so the two implementations can be compared one-for-one.
"""

import argparse
import logging
import sys
from pathlib import Path
from time import perf_counter_ns

from fastapi import FastAPI, Request, Response, BackgroundTasks, HTTPException
import uvicorn

import records_pb2 as pb2            # generated by `protoc`

PROJECT_ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from utils.logger import setup_logger, log_rpc        # noqa: E402
from utils.constants import PROTOTYPE_RECORD


# --------------------------------------------------------------------------- #
# Application factory                                                         #
# --------------------------------------------------------------------------- #

def create_app(pool_size: int, logger: logging.Logger) -> FastAPI:
    """Return a FastAPI app whose state owns the pre-allocated records."""
    records = [PROTOTYPE_RECORD.copy() for _ in range(pool_size)]

    app = FastAPI(
        title="Timestream REST (protobuf)"
    )

    # ---------------------------- endpoint -------------------------------- #
    @app.post("/records", response_class=Response)
    async def get_record_list(request: Request,
                              background_tasks: BackgroundTasks) -> Response:
        """
        Body (bytes)  : timestream.RecordListRequest
        Response body : timestream.RecordListResponse
        """
        t_in = perf_counter_ns()

        # Deserialize request ------------------------------------------------
        raw = await request.body()
        try:
            req_pb = pb2.RecordListRequest.FromString(raw)
        except Exception:                       # pragma: no cover
            raise HTTPException(400, "Invalid protobuf payload")

        if req_pb.count > pool_size:
            raise HTTPException(400, "Requested count exceeds pool size")

        # Build response -----------------------------------------------------
        resp_pb = pb2.RecordListResponse(records=records[:req_pb.count])

        # Log AFTER the response has been sent ------------------------------
        req_id = request.headers.get("req-id")
        background_tasks.add_task(log_rpc, logger, t_in=t_in, req_id=req_id)

        return Response(
            content=resp_pb.SerializeToString(),
            media_type="application/x-protobuf",
        )

    return app


def serve(host: str, port: int, pool_size: int,
          logger_name: str, log_file_path: Path) -> None:
    logger = setup_logger(logger_name, log_file_path)
    app = create_app(pool_size, logger)

    print(f"REST-protobuf server running on http://{host}:{port}")

    # Uvicorn is started **in-process** so that the test harness can spawn
    # this file exactly like the gRPC server.
    uvicorn.run(app, host=host, port=port, log_level="error")


if __name__ == "__main__":
    ap = argparse.ArgumentParser(description="Launch the REST-protobuf server")
    ap.add_argument("--host", default="127.0.0.1")
    ap.add_argument("--port", type=int, required=True, help="Port to listen on")
    ap.add_argument("--pool-size", type=int, required=True, help="Number of records to pre-allocate")
    ap.add_argument("--logger-name", required=True)
    ap.add_argument("--log-file", type=Path, required=True)
    args = ap.parse_args()

    try:
        serve(args.host, args.port, args.pool_size,
              args.logger_name, args.log_file)
    except (KeyboardInterrupt, SystemExit):            # graceful exit
        print("Shutting down REST server")
